class IntersectionObserverManager {
	private static instance: IntersectionObserverManager;
	private observer: IntersectionObserver | null = null;
	private callbacks = new Map<Element, (isVisible: boolean) => void>();
	private visibilityStates = new Map<Element, boolean>();

	private constructor() {
		// Don't create IntersectionObserver here - wait until needed in browser
	}

	private initializeObserver(): void {
		// Only create observer if we're in browser and it doesn't exist yet
		if (typeof window === "undefined" || this.observer) return;

		this.observer = new IntersectionObserver(
			(entries) => {
				entries.forEach((entry) => {
					const element = entry.target;
					const callback = this.callbacks.get(element);
					const wasVisible = this.visibilityStates.get(element);
					const isVisible = entry.isIntersecting;

					if (callback && wasVisible !== isVisible) {
						this.visibilityStates.set(element, isVisible);
						callback(isVisible);
					}
				});
			},
			{
				threshold: 0,
				rootMargin: "16px",
			}
		);
	}

	public static getInstance(): IntersectionObserverManager {
		if (!IntersectionObserverManager.instance) {
			IntersectionObserverManager.instance = new IntersectionObserverManager();
		}
		return IntersectionObserverManager.instance;
	}

	public observe(
		element: Element,
		callback: (isVisible: boolean) => void
	): void {
		// Initialize observer lazily when first needed
		this.initializeObserver();

		// Exit early if we're in SSR or observer creation failed
		if (!this.observer) return;

		this.callbacks.set(element, callback);
		this.visibilityStates.set(element, false);

		this.observer.observe(element);
	}

	public unobserve(element: Element): void {
		this.callbacks.delete(element);
		this.visibilityStates.delete(element);

		// Only unobserve if observer exists
		if (this.observer) {
			this.observer.unobserve(element);
		}
	}

	public disconnect(): void {
		// Only disconnect if observer exists
		if (this.observer) {
			this.observer.disconnect();
		}
		this.callbacks.clear();
		this.visibilityStates.clear();
	}
}

export default IntersectionObserverManager.getInstance();
